import { Command } from "@oclif/command";
import { join, resolve } from "path";
import { readFileSync, readdirSync, writeFile } from "fs-extra";
import recursive from "recursive-readdir";
import { success, pending } from "@staart/errors";
import { parse } from "yaml";
import { config } from "dotenv";
config();

const SRC = resolve(join(".staart", "src"));
let server = "";
try {
  server = readFileSync(join(SRC, "server.ts")).toString();
} catch (error) {}

const generateControllers = async () => {
  if (!server.includes("join("))
    server = `import { join } from "path";\n` + server;
  if (!server.includes("jsonAsyncResponse"))
    server = `import { jsonAsyncResponse } from "@staart/server";\n` + server;
  if (!server.includes("ClassWrapper"))
    server = `import { ClassWrapper } from "@staart/server";\n` + server;
  if (!server.includes("ChildControllers"))
    server = `import { ChildControllers } from "@staart/server";\n` + server;

  const controllers = (await recursive(join(SRC, "controllers")))
    .map((file) => file.split(join(SRC, "controllers").toString())[1])
    .filter((i) => i.endsWith(".ts"));
  const exportName: string[] = [];
  const generatedName: string[] = [];

  controllers.forEach((controller, index) => {
    const controllerFile = readFileSync(
      join(SRC, "controllers", controller)
    ).toString();
    if (
      controllerFile.includes("export class ") ||
      controllerFile.includes("export default class ")
    ) {
      if (controllerFile.includes("export class ")) {
        exportName.push(controllerFile.split("export class ")[1].split(" ")[0]);
      } else {
        exportName.push(
          controllerFile.split("export default class ")[1].split(" ")[0] +
            "__default"
        );
      }
      generatedName.push(`Controller${index}`);
    }
  });

  const importCode = `${exportName
    .map((e, i) => {
      if (e.endsWith("__default")) {
        return `import ${generatedName[i]} from "./controllers${
          controllers[i].split(".ts")[0]
        }";`;
      }
      return `import { ${e} as ${generatedName[i]} } from "./controllers${
        controllers[i].split(".ts")[0]
      }";`;
    })
    .join("\n")}`;

  const insertCode = `
    @ClassWrapper(jsonAsyncResponse)
    @ChildControllers([${generatedName.map((e) => `new ${e}()`).join(", ")}])
    class RootController
  `;
  server =
    importCode +
    server
      .replace("class RootController", insertCode)
      .replace("super();", "super();\n// staart-autogenerated");
  success("Generated paths");
};

const generateRedirects = async () => {
  let redirects: string[] = [];
  try {
    redirects = parse(readFileSync(join(SRC, "redirects.yml")).toString());
  } catch (error) {
    success("Processed no redirect rules");
  }
  const redirectCode = `
    ${redirects
      .map(
        (rule) => `
      this.app.get("${rule.split(" ")[0]}", (req, res) => res.redirect("${
          rule.split(" ")[1]
        }"));
    `
      )
      .join("")}
      // staart-autogenerated
  `;
  server = server.replace("// staart-autogenerated", redirectCode);
  if (redirects.length) success(`Processed ${redirects.length} redirect rules`);
};

const generateCrons = async () => {
  const crons = readdirSync(join(SRC, "crons"));
  const cronImport = crons
    .map(
      (cronFile) =>
        `import cron_${cronFile.split(".ts")[0]} from "./crons/${
          cronFile.split(".ts")[0]
        }";`
    )
    .join("\n");
  const cronCode = `
  ${crons.map((cronFile) => `cron_${cronFile.split(".ts")[0]}();`).join("")}
  `;
  server = cronImport + "\n" + cronCode + "\n" + server;
  if (crons.length) success(`Setup ${crons.length} cron jobs`);
};

const generateStaticFiles = async () => {
  const files = await recursive(join(SRC, "..", "static"));
  const staticFiles = files.map(
    (file) => file.split(join(SRC, "..", "static").toString())[1]
  );
  const staticCode = `
    ${staticFiles
      .map(
        (staticFile, index) => `
      this.app.get("${staticFile}", (req, res) => res.sendFile("${files[index]}"));
    `
      )
      .join("")}
      // staart-autogenerated
  `;
  server = server.replace("// staart-autogenerated", staticCode);
  success(`Serving ${staticFiles.length} static files`);
};

const writeServerFile = async () => {
  await writeFile(
    join(SRC, "app.ts"),
    server.replace("// staart-autogenerated", "")
  );
  success("Generated app.ts file");
  await writeFile(
    join(SRC, "__staart.ts"),
    `
  require("regenerator-runtime");
  require("@babel/polyfill");
  import { Staart } from "./app";
  import { config } from "@anandchowdhary/cosmic";
  import "./init-tests";
  
  const staart = new Staart();
  staart.start(config<number>("port") ?? 80);`
  );
};

export default class Controllers extends Command {
  static description = "setup Staart API app controller";

  async run() {
    await generateControllers();
    await generateRedirects();
    await generateCrons();
    await generateStaticFiles();
    await writeServerFile();
    pending("Compiling TypeScript");
  }
}
